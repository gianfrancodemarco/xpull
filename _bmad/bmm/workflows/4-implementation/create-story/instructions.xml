<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and generate all documents in {document_output_language}</critical>

  <critical>üî• CRITICAL MISSION: You are creating the ULTIMATE story context engine that prevents LLM developer mistakes, omissions or
    disasters! üî•</critical>
  <critical>Your purpose is to enrich a GitHub Issue with comprehensive dev context so the DEV agent has EVERYTHING needed for flawless
    implementation</critical>
  <critical>COMMON LLM MISTAKES TO PREVENT: reinventing wheels, wrong libraries, wrong file locations, breaking regressions, ignoring UX,
    vague implementations, lying about completion, not learning from past work</critical>
  <critical>üö® EXHAUSTIVE ANALYSIS REQUIRED: You must thoroughly analyze ALL artifacts to extract critical context</critical>
  <critical>üî¨ UTILIZE SUBPROCESSES AND SUBAGENTS: Use research subagents, subprocesses or parallel processing if available</critical>
  <critical>‚ùì SAVE QUESTIONS: If you think of questions or clarifications during analysis, save them for the end</critical>
  <critical>üéØ ZERO USER INTERVENTION: Process should be fully automated except for initial story selection or missing documents</critical>

  <step n="1" goal="Determine target story from GitHub">
    <check if="{{story_issue_number}} is provided by user (e.g. #42 or issue number)">
      <action>Fetch the issue from GitHub: GET issue #{story_issue_number} on {github_owner}/{github_repo}</action>
      <action>Verify it has label `story`</action>
      <action>Extract epic_num, story_num, story_title from issue title (format: 'Story {N}.{M}: {title}')</action>
      <action>Set {{story_key}} by converting to kebab-case: {epic_num}-{story_num}-{title_kebab}</action>
      <action>GOTO step 2</action>
    </check>

    <check if="user provided epic and story number (e.g. 2-4 or 1.6 or 'epic 1 story 5')">
      <action>Parse user input to get epic_num and story_num</action>
      <action>Search GitHub issues on {github_owner}/{github_repo} with labels `story` matching title pattern 'Story {epic_num}.{story_num}:'</action>
      <action>Fetch the matching issue</action>
      <action>Extract story details from issue</action>
      <action>Set {{story_key}} from issue title</action>
      <action>GOTO step 2</action>
    </check>

    <!-- Auto-discover from GitHub: find next backlog story -->
    <action>Search GitHub issues on {github_owner}/{github_repo} with labels `story` + `backlog`, state: open</action>
    <action>Sort results by issue number ascending (earliest created = first in backlog)</action>

    <check if="no backlog story issues found">
      <output>üìã No backlog stories found on GitHub.

        All stories are either already enriched, in progress, or done.

        **Options:**
        1. Check GitHub issues to see current status
        2. Provide a specific issue number to enrich
        3. Run the epics-and-stories workflow to create more stories
      </output>
      <ask>Choose option or provide issue number:</ask>
      <action>HALT if no story selected</action>
    </check>

    <action>Select the FIRST backlog story issue (lowest issue number)</action>
    <action>Extract from issue title (e.g., "Story 1.2: User Authentication"):
      - epic_num: first number (e.g., "1")
      - story_num: second number (e.g., "2")
      - story_title: remainder (e.g., "User Authentication")
    </action>
    <action>Set {{story_key}} = "{epic_num}-{story_num}-{title_kebab_case}"</action>
    <action>Set {{story_issue_number}} = issue number</action>
    <action>Set {{story_issue_id}} = issue ID (for API calls)</action>

    <!-- Check if parent epic should be marked in-progress -->
    <action>Find parent epic issue: search issues with label `epic` matching "Epic {epic_num}:"</action>
    <check if="parent epic issue is open and does NOT have any in-progress/review/done stories">
      <output>üìä This is the first story being enriched in Epic {epic_num}</output>
    </check>

    <action>GOTO step 2</action>
  </step>

  <step n="2" goal="Load and analyze core artifacts">
    <critical>üî¨ EXHAUSTIVE ARTIFACT ANALYSIS - This is where you prevent future developer fuckups!</critical>

    <!-- Load all available content through discovery protocol -->
    <invoke-protocol name="discover_inputs" />
    <note>Available content: {epics_content}, {prd_content}, {architecture_content}, {ux_content}, {project_context}</note>

    <!-- Read the current GitHub issue body for existing story content -->
    <action>Fetch full issue body from GitHub issue #{story_issue_number}</action>
    <action>Extract existing content: user story statement, acceptance criteria</action>

    <!-- Analyze epics file for story foundation (local planning reference) -->
    <action>From {epics_content} or GitHub epic issue, extract Epic {{epic_num}} complete context:</action>
    **EPIC ANALYSIS:**
    - Epic objectives and business value
    - ALL stories in this epic for cross-story context
    - Our specific story's requirements, user story statement, acceptance criteria
    - Technical requirements and constraints
    - Dependencies on other stories/epics

    <!-- Previous story analysis for context continuity -->
    <check if="story_num > 1">
      <action>Search GitHub issues for previous stories in this epic: "Story {epic_num}.{prev_num}:" with label `story`</action>
      <action>Read the previous story issue body for dev context and learnings</action>
      **PREVIOUS STORY INTELLIGENCE:**
      - Dev notes and learnings from previous story
      - Review feedback and corrections needed
      - Files that were created/modified and their patterns
      - Testing approaches that worked/didn't work
      - Problems encountered and solutions found
      - Code patterns established
      <action>Extract all learnings that could impact current story implementation</action>
    </check>

    <!-- Git intelligence for previous work patterns -->
    <check if="previous story exists AND git repository detected">
      <action>Get last 5 commit titles to understand recent work patterns</action>
      <action>Analyze 1-5 most recent commits for relevance to current story</action>
      <action>Extract actionable insights for current story implementation</action>
    </check>
  </step>

  <step n="3" goal="Architecture analysis for developer guardrails">
    <critical>üèóÔ∏è ARCHITECTURE INTELLIGENCE - Extract everything the developer MUST follow!</critical>
    **ARCHITECTURE DOCUMENT ANALYSIS:**
    <action>Systematically analyze architecture content for story-relevant requirements:</action>

    <check if="architecture file is single file">
      <action>Load complete {architecture_content}</action>
    </check>
    <check if="architecture is sharded to folder">
      <action>Load architecture index and scan all architecture files</action>
    </check>

    **CRITICAL ARCHITECTURE EXTRACTION:**
    <action>For each architecture section, determine if relevant to this story:</action>
    - **Technical Stack:** Languages, frameworks, libraries with versions
    - **Code Structure:** Folder organization, naming conventions, file patterns
    - **API Patterns:** Service structure, endpoint patterns, data contracts
    - **Database Schemas:** Tables, relationships, constraints relevant to story
    - **Security Requirements:** Authentication patterns, authorization rules
    - **Performance Requirements:** Caching strategies, optimization patterns
    - **Testing Standards:** Testing frameworks, coverage expectations, test patterns
    - **Deployment Patterns:** Environment configurations, build processes
    - **Integration Patterns:** External service integrations, data flows
    <action>Extract any story-specific requirements that the developer MUST follow</action>
  </step>

  <step n="4" goal="Web research for latest technical specifics">
    <critical>üåê ENSURE LATEST TECH KNOWLEDGE - Prevent outdated implementations!</critical>
    **WEB INTELLIGENCE:**
    <action>Identify specific technical areas that require latest version knowledge</action>
    <action>From architecture analysis, identify specific libraries, APIs, or frameworks</action>
    <action>For each critical technology, research latest stable version and key changes</action>
    **EXTERNAL CONTEXT INCLUSION:**
    <action>Include in story any critical latest information the developer needs</action>
  </step>

  <step n="5" goal="Update GitHub issue with comprehensive dev context">
    <critical>üìù ENRICH THE GITHUB ISSUE - The developer's master implementation guide!</critical>

    <action>Compose the enriched issue body, preserving the original story and ACs, and APPENDING full dev context:</action>

    <action>Update the GitHub issue #{story_issue_number} body on {github_owner}/{github_repo} with this structure:</action>

    ```
    ## Story

    As a {role},
    I want {action},
    so that {benefit}.

    ## Acceptance Criteria

    {all_acceptance_criteria_in_BDD_format}

    ## Tasks / Subtasks

    - [ ] Task 1 (AC: #)
      - [ ] Subtask 1.1
    - [ ] Task 2 (AC: #)
      - [ ] Subtask 2.1
    {continue for all tasks}

    ## Dev Notes

    ### Technical Implementation Context
    {story_specific_technical_requirements}

    ### Architecture Compliance
    {architecture_patterns_and_constraints}

    ### Library &amp; Framework Requirements
    {specific_versions_and_usage_patterns}

    ### File Structure Requirements
    {files_to_create_modify_with_paths}

    ### Testing Requirements
    {testing_patterns_frameworks_coverage}

    ### Previous Story Intelligence
    {learnings_from_previous_stories_if_any}

    ### References
    {cite_all_technical_details_with_sources}

    ## Dev Agent Record

    ### Agent Model Used
    <!-- Populated by dev-story workflow -->

    ### Completion Notes
    <!-- Populated by dev-story workflow -->

    ### File List
    <!-- Populated by dev-story workflow -->
    ```

    <action>CRITICAL: Set story status label to ready-for-dev</action>
    <action>Remove label `backlog` from issue #{story_issue_number}</action>
    <action>Add label `ready-for-dev` to issue #{story_issue_number}</action>
  </step>

  <step n="6" goal="Validate and finalize">
    <invoke-task>Validate against checklist at {installed_path}/checklist.md using _bmad/core/tasks/validate-workflow.xml</invoke-task>

    <action>Verify the GitHub issue body is complete and well-structured</action>

    <action>Report completion</action>
    <output>**üéØ ULTIMATE BMad Method STORY CONTEXT CREATED, {user_name}!**

      **Story Details:**
      - Story ID: {{story_id}}
      - Story Key: {{story_key}}
      - GitHub Issue: #{story_issue_number}
      - Status: ready-for-dev
      - URL: https://github.com/{github_owner}/{github_repo}/issues/{{story_issue_number}}

      **Next Steps:**
      1. Review the comprehensive story at the GitHub issue URL
      2. Run `dev-story` for optimized implementation (will auto-assign, create branch &amp; draft PR)
      3. Run `code-review` when complete

      **The developer now has everything needed for flawless implementation!**
    </output>
  </step>

</workflow>
